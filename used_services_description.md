## Используемые сервисы и их описания:


## n8n

n8n — основной слой оркестрации автоматизации (workflow-движок), который выполняет всю «прикладную» логику: прием сообщений из каналов, обработку, обращение к Базе Знаний, генерацию ответа, отправку ответа обратно в канал, а также запуск платежных и пост-платежных сценариев.

### Workflow-архитектура
- В системе есть **10 основных типов workflow** (на практике их может быть меньше или больше, потому что некоторые воркфлоу дублируются и «плодятся» под конкретные подключения).
- Подробные инструкции по каждому типу workflow уже есть в **Notion** (ссылка/раздел — в внутренней документации).
- Основной workflow генерации сообщений предполагается как общий и переиспользуемый (не должен массово дублироваться без необходимости). При этом ingress-воркфлоу по некоторым каналам могут требовать дублирования.

### Что нужно сделать (интеграция с SaaS / FastAPI backend)
Задача разработчика — интегрировать создание новых пользователей, компаний и подключений каналов в SaaS с n8n.

#### Воркфлоу, которые нужно связать с backend через webhook
Нужно встроить (или корректно настроить) webhook-обмен между FastAPI backend и n8n для следующих воркфлоу:
- **Telegram Ingress**
- **WhatsApp Ingress**
- **Facebook + Instagram Ingress**
- **Gmail Ingress**
- **Gmail Output**

В результате backend должен уметь:
- инициировать подключение канала (создать/обновить конфиг),
- передать в n8n идентификаторы tenant’а (user_id, company_id, channel_id и т.п.),
- создать/обновить **credentials** программно,
- включить/переключить нужные n8n-узлы под конкретного клиента,
- связать n8n с актуальной Базой Знаний в Supabase.

#### Telegram: важное правило дублирования
Для Telegram при подключении нового пользователя нужно:
- **дублировать** ingress workflow (на основе шаблона),
- **создавать новые credentials программно**,
- привязывать дубликат воркфлоу к конкретному клиенту/компании.

#### WhatsApp: важное правило минимальных изменений
Для WhatsApp при новом подключении чаще всего не нужно создавать новый workflow «целиком». Обычно достаточно:
- создать/обновить credentials,
- обеспечить прием входящих сообщений через WAHA → webhook,
- корректно привязать входящие события к конкретной компании/пользователю на backend.

#### Supabase и Gmail: отдельные credentials + автоматизация
- Для каждого пользователя/компании должны создаваться отдельные узлы/настройки работы с Supabase (и, при необходимости, отдельные credentials).
- Отдельные credentials под Gmail также должны создаваться и обновляться через n8n + backend (FastAPI), чтобы процесс был автоматическим.

#### Создание Баз Знаний через n8n
При создании новой компании и при загрузке CSV/XLSX нужно обеспечить:
- создание новой Базы Знаний (таблиц/пространства данных) в Supabase,
- корректную привязку этих таблиц к tenant’у,
- обновление/инициализацию узлов n8n, которые читают и используют БЗ конкретного клиента.


## Supabase
**Tables**
**Проект StripeWA_sessions** *(для сохранения сессий активности клиентов бизнесов в WA и TG для объединения нескольких подряд идущих сообщений в одно + для флагов статусов оплат клиентов и отправки им Privacy Policy)*
- wa_sessions *(WA and TG)*
- wa_buffer_messages *(WA and TG)*
- sessions_statuses *(all social networks + Email)*

**Проект StripeKnowledgeBase** *(здесь хранятся все базы знаний бизнесов)*
*(TODO) есть уязвимость: все БЗ разных клинетов создаются в одном проекте -> надо реализовать БЗ так, чтобы их можно было различать относительно бизнесов (на случай того, если разные бизнесы создадут БЗ с одинаковыми названиями)*
- DB Product <Name> -> БЗ продукта
- DB Service <Name> -> БЗ сервиса

##### sessions_statuses
**ENUM for payment_status**
- no_payment_link *(default value)*
- payment_link_sent *(each time a new payment link is sent)*
- paid *(when a payment link is paid, this status appears. It remains until this client doesn't initiate a new order)*

### Дополнения к Supabase (по контексту)
- Нужно реализовать гарантированную **уникальность** таблиц/Баз Знаний между бизнесами (например, через префиксы/суффиксы с company_id или отдельные схемы/проекты; решение выбирается разработчиком).
- Буферизация нескольких подряд идущих сообщений в одно сейчас корректно работает для **WhatsApp и Telegram**, но ее нужно довести и сделать аналогично для **Facebook и Instagram** (с сопоставлением сессий/статусов).



## MongoDB

MongoDB используется для хранения истории диалогов с моделью (контекст переписок), чтобы быстро получать историю без нагрузки на основную реляционную часть.

### Требования и важные моменты
- Нужны **TTL-индексы**, чтобы старые истории автоматически удалялись и база не разрасталась бесконечно.
- Нужно учитывать возможное **переполнение** при росте числа пользователей:
  - контролировать объем документов,
  - не превышать лимиты размера документа,
  - продумать стратегию очистки/архивирования (при необходимости).
- История должна быть строго разделена по tenant’ам (business/company/user), чтобы исключить пересечения данных.



## Stripe

Stripe используется в двух направлениях:
1) **Подписки SaaS** — бизнес платит за доступ к платформе.
2) **Платежи конечных клиентов бизнеса** — покупка товаров/услуг у бизнеса через **Stripe Connect**.

### 1) Подписки SaaS (billing)
Подписки можно реализовать:
- через **Payment Links (Subscriptions)**,
- или через **Checkout Sessions (Subscriptions)**.

Логика подписок:
- После регистрации бизнес получает **trial**.
- По окончании trial пользователь должен оформить подписку.
- Если подписки нет — доступ к подключениям и ключевому функционалу должен быть ограничен.
- Апгрейд подписки: открывается возможность подключить больше каналов.
- Даунгрейд подписки: пользователь должен удалить лишние подключения, чтобы уложиться в лимит нового тарифа.
- Возврат средств при переходе на более дешевый тариф не требуется (политика возвратов не применяется).

### 2) Stripe Connect (платежи клиентов бизнеса)
Stripe Connect нужен, чтобы бизнес подключался к платформе через «материнский» Stripe-аккаунт:
- бизнес проходит подключение (onboarding),
- создается связка «бизнес → connected account»,
- транзакции клиентов бизнеса проходят через платформу и зачисляются бизнесу,
- комиссия на старте = **0** (можно предусмотреть поле на будущее).

Что нужно обеспечить:
- сохранение и управление connected_account_id,
- выгрузку транзакций именно конкретного бизнеса,
- запись транзакций в логи покупок/оплат в SaaS,
- поддержку отключения (disconnect) и корректной очистки связей.

### Stripe ↔ n8n (обязательная синхронизация)
Важно предусмотреть, что при подключении Stripe Connect:
- в n8n должны появляться/обновляться соответствующие **credentials** и **ноды** (если платежная логика/уведомления проходят через n8n),
- backend (FastAPI) должен уметь триггерить обновление этих сущностей,
- также должен быть предусмотрен сценарий отключения Stripe (и в n8n, и в базе данных).



## Cloudinary

Cloudinary — облачное хранилище медиафайлов. Нужен, чтобы бизнес мог получить публичные ссылки на изображения/видео и использовать их в Базе Знаний.

### Организация хранения
- Для каждого пользователя создается отдельная папка по его **ID**.
- Внутри две папки: **«сервис»** и **«продукт»**.
- В каждой папке:
  - фото — неограниченно,
  - видео — максимум одно (приветственное видео).

### Что нужно сделать
- В целом функционал уже реализован, требуется:
  - протестировать создание папок и структуру,
  - проверить права доступа и корректность публичных ссылок,
  - проверить виджет/интерфейс во FrontEnd,
  - убедиться, что удаление из SaaS корректно удаляет медиа в Cloudinary и не оставляет «висячих» ссылок.



## Meta for Developers

Meta for Developers используется для подключений **Instagram** и **Facebook** (вход через виджеты/логин и дальнейшая работа с сообщениями через вебхуки).

### Виджеты логина (минимизация боли подключения)
В разделе Integrations должны быть два виджета/кнопки:
- Login with Instagram
- Login with Facebook

Пользователь логинится, а backend:
- регистрирует подключение,
- сохраняет токены/ключи,
- активирует соответствующий ingress workflow в n8n.

### Ключевая сложность: App Review и стратегия «пула приложений»
У Meta есть App Review, который обычно долгий и сложный (скринкасты, тестовые кейсы, Privacy Policy и т.д.). Если делать новое приложение под каждого клиента и каждый раз проходить Review — это будет слишком долго.

Что нужно сделать:
- Использовать стратегию «пула» заранее подготовленных приложений, которые уже прошли App Review и имеют нужные разрешения.
- Менеджер должен подготовить несколько пустых приложений по инструкции (шаблоны текстов и скринкасты лежат в Notion).
- При подключении реального клиента ему выделяется одно из таких приложений, и подключение происходит быстро, без повторного App Review.
- Backend должен поддерживать привязку «клиент → существующее приложение Meta» и хранить это в базе данных подключений.



# WAHA

WAHA — self-hosted сервис для подключения WhatsApp клиента через механику WhatsApp Web:
- создается сессия по QR-коду,
- входящие сообщения уходят на webhook,
- можно отправлять ответы программно.

### Статус и что нужно сделать
- Контейнер WAHA в целом поднят, нужно:
  - перепроверить работу на хостинге,
  - реализовать/довести сценарий подключения через QR-код (end-to-end),
  - протестировать стабильность сессий и восстановление,
  - продумать масштабирование (количество сессий, изоляция, лимиты).
- Текущее состояние: ориентировочно готово на ~50%, требуется довести до стабильной эксплуатации.



# TikTok

Для TikTok нет нормального API для автоматизации личных сообщений и нет механизма, аналогичного «подключению аккаунта» как у WhatsApp/Telegram/Meta. Плюс есть ограничения на автоматизацию сообщений для пользователей из ЕС/США, что важно, потому что продукт нацелен на европейский рынок.

### Стратегия: TikTok лиды → WhatsApp через Ads Manager
Практическое решение — вести лидов из TikTok в WhatsApp через **TikTok Ads Manager**:
- менеджер настраивает рекламную кампанию на одно/несколько видео,
- появляется виджет/кнопка перехода в WhatsApp,
- фактически все коммуникации идут в WhatsApp.

### Что нужно реализовать
- Подробную инструкцию для менеджера, как настраивать Ads Manager и кампании.
- Механизм фиксации источника (TikTok) при переходе в WhatsApp:
  - возможно через промежуточную ссылку/вебхук/параметры,
  - чтобы в Conversations и логах покупок/переписок было видно, что лид пришел из TikTok, даже если сообщение физически приходит в WhatsApp.
- Так как настройка TikTok часто делается через видеосвязь, это завязывается на календарь встреч с менеджером (см. ниже).


---

## SystemData (единая база ключей и токенов)

Нужно реализовать базу данных **SystemData** (аналог SystemData в Notion), где хранятся:
- все пользователи/бизнесы,
- ключи/токены подключений для всех соцсетей и сервисов,
- статусы подключений и служебные поля.

### Доступ менеджеров
Нужен механизм доступа:
- у менеджера есть доступ к SystemData,
- но он видит и редактирует токены **только** тех бизнесов, которые ему назначены,
- у бизнеса не может быть больше одного менеджера,
- один и тот же бизнес не может быть назначен двум менеджерам.

---

## Полное удаление аккаунта (hard delete)

Нужно реализовать механизм полного удаления аккаунта, который удаляет все следы пользователя:
- все связи и credentials/ноды в n8n,
- все базы знаний/таблицы в Supabase,
- папки и медиа в Cloudinary,
- токены и ключи в SystemData,
- историю чатов в MongoDB,
- подписку Stripe (и связанные сущности),
- Stripe Connect (disconnect) и все связанные данные,
- все соединения со всеми соцсетями (WAHA-сессии, Meta-токены и т.д.).

---

## Метрики

Во FrontEnd уже есть блоки метрик, но часть значений сейчас захардкожена или сделана заглушками.

Что нужно реализовать:
- сбор и расчет метрик на backend на основе данных из баз данных и Stripe,
- API для отдачи метрик во FrontEnd,
- разделение метрик по бизнесу/компании и по каналам,
- учет источников лидов (включая TikTok → WhatsApp) в аналитике.
